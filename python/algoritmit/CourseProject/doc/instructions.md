# DSA Project topics & assesment

This project will be assessed and used as the basis for the course assessment. Remember that weekly assignments will be also considered when final grade is determined!

Group work: 2-4 members, everyone has to report the hours and tasks completed

The submitted documentation should show the following steps:

Research: Begin with thorough research on your chosen project to understand the requirements and existing solutions.

Include references to the research documents/resources (online) that you used when planning your project.

Design: Plan the architecture of your project, including the choice of data structures and algorithms. Consider the trade-offs in terms of time and space complexity.

Include your plan to your final report. The plan can include images (a picture tells more than 1000 words sometimes…)

Implementation: Code your project with clear documentation and comments to explain your logic.

Include the code file to the submission, or attach it to your document in appendix.

Testing and Analysis: Test your project for various scenarios and analyze the performance (time and space complexity).

Generate a test scenario, explain the choices, report the results and discuss them. For example, do the empirical results correspond to the theoretical complexity of the algorithms you implemented?

Presentation: Prepare a comprehensive report, including the problem statement, your solution, complexity analysis, challenges faced, and lessons learned.

The report should thus consist of the following sections:

1. Introduction: What is your project about?

2. Research and planning: Include references and discussion on any research materials that you use as the basis for your project (it can be ChatGPT / copilot but remember to mention it!!!). Include your plan on the implementation.

3. Implementation: Remember to comment on your code for documentation! Attach your code either to the report, or submit it as a separate file.

4. Testing and results: Plan a test case and report the details of your tests. Report the results.

5. Discussion: Analyze the results of your tests

There is no requirement on the length of the report. I hate length restrictions, since some of us use vivid language and still strictly staying in facts, but others use more compact and straight communication.

# Assessment Criteria

Part 1: Technical implementation (20 marks)

· Problem Solving and Algorithmic Complexity (30% = 6 marks)

· Originality in approaching the problem.

· Efficiency and complexity of the implemented algorithms.

· Data Structures Usage (20% = 4 marks)

· Appropriateness of data structures chosen for the problem.

· Understanding of the data structures' properties and justification of their choice.

· Code Quality and Organization (20% = 4 marks)

· Readability, commenting, and formatting.

· Modularity, use of functions/classes, and code organization.

· Execution and Functionality (15% = 3 marks)

· Correctness of the output.

· Handling of edge cases and errors.

· Report and Documentation (10% = 2 mark)

· Clarity and thoroughness of the project report.

· Explanation of the design decisions, algorithms, and data structures used.

· Innovation and Creativity (5% = 1 mark)

· Creativity in project selection, approach, or implementation.

· Going beyond the course requirements in solving the problem.

Part 2: Report (10 marks)

· Introduction and Objective (20%)

· Clear presentation of the problem and project objectives.

· Technical Description (30%)

· Detailed explanation of the algorithms and data structures used, including complexity analysis.

· Implementation (20%)

· Discussion on the implementation details, challenges faced, and solutions.

· Results and Evaluation (20%)

· Presentation and evaluation of the results, including test cases and their analysis.

· Conclusion and Future Work (10%)

· Summary of achievements, limitations, and potential future improvements.

Part 3: Determining the Final Grade

After assessing each project based on the above criteria, calculate the total marks out of 30 as a percentage. Then, you can use the following scale to determine the final grade:

· 0% – 40%: Failed (0)

· 41% - 55%: Poor (1)

· 56% - 65%: Satisfactory (2)

· 66% - 79%: Good (3)

· 80% - 89%: Fairly Good (4)

· 90% - 100%: Excellent (5)

Selecting a project from this list should offer a challenging yet rewarding experience, showcasing your mastery of data structures and algorithms.

1. Custom Data Structure Library

Objective: Implement a library that includes various data structures like linked lists, queues, stacks, AVL trees, BSTs, heaps, and graphs. For each structure, implement key operations such as insertion, deletion, searching, and sorting.

Complexity Analysis: Include a detailed analysis of the time and space complexity for each operation in your library.

Applications: Demonstrate the use of these data structures in practical scenarios, like managing a database, organizing files, or network routing.

2. Pathfinding Visualizer

Objective: Create a visualization tool for pathfinding algorithms on graphs. Implement algorithms like BFS, DFS, Dijkstra’s, and A*.

Data Structures: Use graphs to represent the map, and heaps (priority queues) to efficiently find the next node to explore.

Visualization: Show step-by-step how these algorithms traverse the graph to find the shortest path between two points.

3. Text Editor Simulation

Objective: Develop a simple text editor that supports operations like insertion, deletion, search, and undo.

Data Structures: Use a doubly linked list to represent the text, a stack for undo operations, and a trie for efficient word search and autocomplete.

Challenge: Implement syntax highlighting and word suggestions by analyzing the complexity of operations.

4. Dynamic Web Crawler

Objective: Build a web crawler that navigates the internet to gather and index web content, demonstrating the use of graphs for web structure representation.

Data Structures: Utilize graphs for storing web links, queues for URLs to be crawled, and heaps for prioritizing pages based on certain criteria (e.g., relevance or update frequency).

Algorithms: Apply BFS or DFS for traversal, and design a simple search algorithm to query the indexed content.

5. E-commerce Backend Simulation

Objective: Simulate the backend for an e-commerce platform, focusing on inventory management, product recommendation, and order processing.

Data Structures: Use trees (BST or AVL) for product inventory, heaps for managing best-selling items, and graphs for product recommendations based on user behavior.

Functionality: Implement sorting algorithms for product listings and graph traversal algorithms for recommendations.

6. Real-time Strategy Game AI

Objective: Design AI for a real-time strategy (RTS) game that can analyze the game state and make decisions.

Data Structures: Employ graphs for game map representation, allowing for pathfinding and strategic positioning. Use trees for decision-making processes (e.g., behavior trees).

Algorithms: Incorporate DFS or BFS for exploration and A* for optimal pathfinding. Design algorithms for AI behavior that factor in algorithmic complexity to ensure responsiveness.

7. Social Network Analysis

Objective: Create a tool to analyze social networks, focusing on finding connections, communities, or influential figures.

Data Structures: Use graphs to represent the social network, with nodes as individuals and edges as connections.

Algorithms: Implement graph traversal algorithms to explore connections, and apply algorithms like PageRank or community detection algorithms to analyze the network structure.